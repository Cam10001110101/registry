package verification

import (
	"crypto/rand"
	"encoding/base64"
	"fmt"
)

// TokenLength defines the number of bytes for the verification token.
// 128 bits = 16 bytes provides cryptographically secure randomness
// suitable for domain ownership verification.
const TokenLength = 16

// GenerateVerificationToken generates a cryptographically secure 128-bit (16 bytes)
// random token for domain ownership verification. The token is encoded using base64url
// (RFC 4648) which is both URL-safe and DNS TXT record safe.
//
// This function is designed for use in both DNS TXT record verification
// (mcp-verify=<token>) and HTTP-01 web challenge verification
// (https://domain/.well-known/mcp-challenge/<token>).
//
// Security considerations:
// - Uses crypto/rand for cryptographically secure random number generation
// - 128 bits provides 2^128 possible values, making collision probability negligible
// - Base64url encoding ensures compatibility with DNS and HTTP standards
// - Tokens should be treated as single-use and rotated regularly
//
// Returns:
// - A base64url-encoded token string suitable for verification
// - An error if the system's entropy source is unavailable
//
// Example usage:
//
//	token, err := GenerateVerificationToken()
//	if err != nil {
//	    return fmt.Errorf("failed to generate verification token: %w", err)
//	}
//	// Use token in DNS: mcp-verify=<token>
//	// Or HTTP: /.well-known/mcp-challenge/<token>
func GenerateVerificationToken() (string, error) {
	// Allocate byte slice for random data
	randomBytes := make([]byte, TokenLength)

	// Generate cryptographically secure random bytes
	// crypto/rand.Read uses the operating system's entropy source
	_, err := rand.Read(randomBytes)
	if err != nil {
		return "", fmt.Errorf("failed to generate cryptographically secure random bytes: %w", err)
	}

	// Encode using base64url (RFC 4648) for URL and DNS safety
	// base64url encoding is URL-safe and doesn't contain characters
	// that would be problematic in DNS TXT records or HTTP URLs
	token := base64.URLEncoding.WithPadding(base64.NoPadding).EncodeToString(randomBytes)

	return token, nil
}

// ValidateTokenFormat validates that a token string matches the expected format
// for a verification token generated by GenerateVerificationToken.
//
// This function checks:
// - Token length matches expected base64url-encoded length for 128-bit input
// - Token contains only valid base64url characters
// - Token is properly formatted without padding
//
// Parameters:
// - token: The token string to validate
//
// Returns:
// - true if the token format is valid, false otherwise
//
// Note: This function only validates format, not authenticity or ownership.
// Actual verification requires checking the token against stored values.
func ValidateTokenFormat(token string) bool {
	if token == "" {
		return false
	}

	// Expected length for base64url encoding of 16 bytes without padding
	// 16 bytes * 8 bits/byte = 128 bits
	// 128 bits / 6 bits per base64 character = 21.33, rounded up to 22 characters
	expectedLength := 22

	if len(token) != expectedLength {
		return false
	}

	// Check if string contains only valid base64url characters
	// Base64url uses: A-Z, a-z, 0-9, -, _
	for _, char := range token {
		if !((char >= 'A' && char <= 'Z') ||
			(char >= 'a' && char <= 'z') ||
			(char >= '0' && char <= '9') ||
			char == '-' || char == '_') {
			return false
		}
	}

	return true
}

// TokenInfo holds metadata about a generated verification token
type TokenInfo struct {
	// Token is the base64url-encoded verification token
	Token string `json:"token"`

	// Length is the number of bytes of entropy in the token
	Length int `json:"length"`

	// Encoding describes the encoding scheme used
	Encoding string `json:"encoding"`

	// DNSRecord shows how to use the token in a DNS TXT record
	DNSRecord string `json:"dns_record"`

	// HTTPPath shows the HTTP path where the token should be served
	HTTPPath string `json:"http_path"`
}

// GenerateTokenWithInfo generates a verification token and returns detailed
// information about how to use it for domain verification.
//
// This is a convenience function that wraps GenerateVerificationToken()
// and provides additional metadata useful for user interfaces and documentation.
//
// Returns:
// - TokenInfo struct with token and usage information
// - An error if token generation fails
func GenerateTokenWithInfo() (*TokenInfo, error) {
	token, err := GenerateVerificationToken()
	if err != nil {
		return nil, err
	}

	return &TokenInfo{
		Token:     token,
		Length:    TokenLength,
		Encoding:  "base64url",
		DNSRecord: fmt.Sprintf("mcp-verify=%s", token),
		HTTPPath:  fmt.Sprintf("/.well-known/mcp-challenge/%s", token),
	}, nil
}
